<!doctype html>
<html>
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<title>Introdução ao Desenvolvimento Web com Flask</title>

        <link rel="stylesheet" href="reveal.js/dist/reset.css">
        <link rel="stylesheet" href="reveal.js/dist/reveal.css">
        <link rel="stylesheet" href="reveal.js/dist/theme/white.css">
        <link rel="stylesheet" href="css/app.css">
		<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/reveal.js/4.3.1/plugin/highlight/monokai.min.css">
	</head>
	<body>
		<div class="reveal">
			<div class="slides">

				<section>
					<h1>Introdução ao Desenvolvimento Web com Flask</h1>
					<p>Baseado em "Flask Web Development" por Miguel Grinberg</p>
					<p><small>Capítulos 1, 2, 3 e 4</small></p>
					<br>
					<img src="img/flask-livro.jpg" alt="Capa do livro Flask Web Development" style="height: 200px;">
				</section>

				<section>
					<h2>Por Que Flask?</h2>
					<ul>
						<li>É um "microframework".</li>
						<li>Leve, mas extensível.</li>
						<li>Permite controle criativo total sobre suas aplicações web.</li>
						<li>Oferece um núcleo robusto com funcionalidades básicas.</li>
						<li>A maioria das funcionalidades de alto nível (bancos de dados, formulários, autenticação) são fornecidas por extensões.</li>
						<li>Flexibilidade na escolha de componentes da aplicação.</li>
					</ul>
				</section>

				<section>
					<section>
						<h2>Capítulo 1: Instalação</h2>
					</section>

					<section>
						<h3>Conceitos Introdutórios de Programação Web</h3>
						<h4>Comunicação Cliente-Servidor</h4>
						<ul>
							<li>O desenvolvimento web baseia-se na interação entre **clientes** (geralmente navegadores web) e **servidores**.</li>
							<li>O cliente faz uma **requisição** a um servidor (ex: digita um URL no navegador).</li>
							<li>O servidor **processa** a requisição e envia uma **resposta** de volta ao cliente.</li>
							<li>Esta resposta é então interpretada pelo cliente (ex: o navegador renderiza o HTML).</li>
						</ul>
					</section>

					<section>
						<h3>Conceitos Introdutórios de Programação Web</h3>
						<h4>Protocolo HTTP (Hypertext Transfer Protocol)</h4>
						<ul>
							<li>É o protocolo que rege a comunicação entre cliente e servidor na web.</li>
							<li>Definido por **métodos de requisição** (verbos HTTP) que indicam a ação desejada (GET, POST, PUT, DELETE, etc.).</li>
							<li>A resposta do servidor inclui um **código de status** (ex: 200 OK, 404 Not Found, 500 Internal Server Error) e o corpo da resposta (ex: HTML, JSON).</li>
						</ul>
                        <div style="display: flex; justify-content: center;">
                            <img src="img/methods.png" alt="Métodos HTTP" style="width: 100%; max-width: 600px;" />
                        </div>
                        <div style="background: #e7f3fe; border-left: 6px solid #2196F3; padding: 12px; margin: 16px 0;">
                            <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Reference/Status" target="_blank">
                                Lista de códigos de status http
                            </a>
                        </div>
					</section>

					<section>
						<h3>Conceitos Introdutórios de Programação Web</h3>
						<h4>Servidores Web</h4>
						<ul>
							<li>Programas que escutam requisições HTTP e servem respostas.</li>
							<li>Para Python, o servidor web passa as requisições para a aplicação usando o protocolo **WSGI (Web Server Gateway Interface)**.</li>
							<li>Flask inclui um servidor de desenvolvimento para testes. Servidores de produção (como Gunicorn, uWSGI) são necessários para aplicações reais.</li>
						</ul>
					</section>

					<section>
						<h3>Requisitos e Compatibilidade</h3>
						<ul>
							<li>Python instalado.</li>
							<li>Exemplos verificados com Python 3.5 e 3.6.</li>
							<li>Recomendado Python 3.x, pois Python 2.7 não será mais mantido após 2020.</li>
							<li>Compatível com sistemas Unix (Linux, macOS) e Windows (com alternativas ou WSL).</li>
						</ul>
					</section>

					<section>
						<h3>Ambientes Virtuais</h3>
						<ul>
							<li>Cópia isolada do interpretador Python.</li>
							<li>Instalação privada de pacotes, sem afetar o interpretador global.</li>
							<li>Previne "bagunça" de pacotes e conflitos de versão.</li>
							<li>Pode ser criado e gerenciado sem direitos de administrador.</li>
						</ul>
					</section>

					<section>
						<h3>Criando um Ambiente Virtual</h3>
						<h4>Com Python 3 (<code>venv</code>)</h4>
						<pre><code class="language-bash">
# Criar diretório da aplicação (opcional, se não clonou o repositório)
$ mkdir flasky
$ cd flasky

# Criar ambiente virtual (convenção: 'venv')
$ python3 -m venv venv
						</code></pre>
						<p><small><code>python3 -m venv</code> executa o pacote <code>venv</code> como um script autônomo.</small></p>
					</section>

					<section>
						<h3>Ativando o Ambiente Virtual</h3>
						<h4>Linux ou macOS</h4>
						<pre><code class="language-bash">
$ source venv/bin/activate
						</code></pre>
						<h4>Microsoft Windows</h4>
						<pre><code class="language-bash">
$ venv\Scripts\activate
						</code></pre>
						<p><small>O prompt de comando é modificado para incluir o nome do ambiente.</small></p>
					</section>

					<section>
						<h3>Instalando Pacotes Python com <code>pip</code></h3>
						<ul>
							<li><code>pip</code> é o gerenciador de pacotes incluído em todos os ambientes virtuais.</li>
							<li>Sempre use <code>pip</code> no ambiente virtual ativado.</li>
						</ul>
						<pre><code class="language-bash">
(venv) $ pip install flask
						</code></pre>
						<p><small>Isso instala Flask e suas dependências (Werkzeug, Jinja2, Click).</small></p>
					</section>

					<section>
						<h3>Verificando a Instalação</h3>
						<pre><code class="language-bash">
(venv) $ pip freeze
(venv) $ python
>>> import flask
>>>
						</code></pre>
						<p><small>Se nenhum erro aparecer, Flask foi instalado corretamente.</small></p>
					</section>
				</section>

				<section>
					<section>
						<h2>Capítulo 2: Estrutura Básica da Aplicação</h2>
					</section>

					<section>
						<h3>Instanciação da Aplicação</h3>
						<ul>
							<li>Toda aplicação Flask cria uma instância da aplicação.</li>
							<li>O servidor web passa todas as requisições a este objeto, usando o protocolo WSGI.</li>
							<li>Objeto da classe <code>Flask</code>:</li>
						</ul>
						<pre><code class="language-python">
from flask import Flask
app = Flask(__name__)
						</code></pre>
						<p><small><code>__name__</code> ajuda Flask a localizar arquivos da aplicação como templates e imagens.</small></p>
					</section>

					<section>
						<h3>Rotas e Funções de View</h3>
						<ul>
							<li>Flask mapeia URLs para funções Python.</li>
							<li>Associação URL-função é chamada de <b>rota</b>.</li>
							<li>Definidas com o decorador <code>app.route</code>.</li>
						</ul>
						<pre><code class="language-python">
@app.route('/')
def index():
    return '<h1>Hello World!</h1>'
						</code></pre>
						<p><small>Funções como <code>index()</code> que tratam URLs da aplicação são chamadas de <b>funções de view</b>.</small></p>
					</section>

					<section>
						<h3>Rotas Dinâmicas</h3>
						<ul>
							<li>Permitem componentes variáveis na URL.</li>
							<li>Partes dinâmicas são passadas como argumentos para a função de view.</li>
						</ul>
						<pre><code class="language-python">
@app.route('/user/<name>')
def user(name):
    return '<h1>Hello, {}!</h1>'.format(name)
						</code></pre>
						<p><small>Tipos suportados: <code>string</code> (padrão), <code>int</code>, <code>float</code>, <code>path</code>.</small></p>
					</section>

					<section>
						<h3>Ciclo Requisição-Resposta</h3>
						<ul>
							<li><b>Contextos:</b> <code>Application Context</code> e <code>Request Context</code>.</li>
							<li>Tornam objetos (como <code>request</code> e <code>session</code>) globalmente acessíveis de forma temporária e segura em ambientes multi-thread.</li>
						</ul>
						<pre><code class="language-python">
from flask import request

@app.route('/')
def index():
    user_agent = request.headers.get('User-Agent')
    return '&lt;p&gt;Your browser is {}&lt;/p&gt;'.format(user_agent)
						</code></pre>
					</section>

					<section>
						<h3>Objetos Globais de Contexto (Tabela 2-1) </h3>
						<table>
							<thead>
								<tr>
									<th>Variável</th>
									<th>Contexto</th>
									<th>Descrição</th>
								</tr>
							</thead>
							<tbody>
								<tr>
									<td><code>current_app</code></td>
									<td>Application</td>
									<td>A instância da aplicação ativa.</td>
								</tr>
								<tr>
									<td><code>g</code></td>
									<td>Application</td>
									<td>Um objeto que a aplicação pode usar para armazenamento temporário durante o tratamento de uma requisição. É resetado a cada requisição.</td>
								</tr>
								<tr>
									<td><code>request</code></td>
									<td>Request</td>
									<td>O objeto de requisição, que encapsula o conteúdo de uma requisição HTTP enviada pelo cliente.</td>
								</tr>
								<tr>
									<td><code>session</code></td>
									<td>Request</td>
									<td>A sessão do usuário, um dicionário que a aplicação pode usar para armazenar valores que são "lembrados" entre requisições.</td>
								</tr>
							</tbody>
						</table>
					</section>

					<section>
						<h3>Hooks de Requisição</h3>
						<ul>
							<li>Funções que são executadas antes ou depois do processamento de cada requisição.</li>
							<li>Implementados como decoradores:
								<ul>
									<li><code>before_request</code>: Executado antes de cada requisição.</li>
									<li><code>before_first_request</code>: Executado apenas antes da primeira requisição.</li>
									<li><code>after_request</code>: Executado depois de cada requisição, se não houver exceções.</li>
									<li><code>teardown_request</code>: Executado depois de cada requisição, mesmo com exceções.</li>
								</ul>
							</li>
						</ul>
						<p><small>Dados podem ser compartilhados usando <code>g</code>.</small></p>
					</section>

					<section>
						<h3>Respostas</h3>
						<ul>
							<li>O valor de retorno de uma função de view é a resposta à requisição.</li>
							<li>Inclui texto (HTML) e código de status HTTP (padrão 200 OK).</li>
							<li>Pode retornar:
								<ul>
									<li>String (HTML)</li>
									<li>String, Código de Status (ex: <code>return '<h1>Bad Request</h1>', 400</code>).</li>
									<li>String, Código de Status, Dicionário de Headers.</li>
									<li>Objeto de Resposta (usando <code>make_response()</code>).</li>
								</ul>
							</li>
						</ul>
						<pre><code class="language-python">
from flask import make_response

@app.route('/')
def index():
    response = make_response('&lt;h1&gt;This document carries a cookie!&lt;/h1&gt;')
    response.set_cookie('answer', '42')
    return response
						</code></pre>
					</section>

					<section>
						<h3>Redirecionamentos e Erros</h3>
						<ul>
							<li><b>Redirecionamento:</b> Não inclui documento, apenas uma nova URL para o navegador.</li>
							<li>Comumente usa status 302 e header Location.</li>
							<li>Função auxiliar <code>redirect()</code>.</li>
							<li><b>Erros:</b> Função <code>abort()</code> levanta uma exceção para tratamento de erros (ex: 404 Not Found).</li>
						</ul>
					</section>

					<section>
						<h3>Servidor Web de Desenvolvimento</h3>
						<ul>
							<li>Iniciado com <code>flask run</code>.</li>
							<li>Procura a instância da aplicação na variável de ambiente <code>FLASK_APP</code>.</li>
							<li>Exemplo: <code>export FLASK_APP=hello.py</code> (Linux/macOS) ou <code>set FLASK_APP=hello.py</code> (Windows).</li>
							<li>Para desenvolvimento e testes (não para produção!).</li>
						</ul>
					</section>

					<section>
						<h3>Modo Depuração (Debug Mode)</h3>
						<ul>
							<li>Habilita recarregador (<code>reloader</code>) e depurador (<code>debugger</code>).</li>
							<li><code>reloader</code>: Reinicia o servidor automaticamente ao modificar arquivos.</li>
							<li><code>debugger</code>: Ferramenta web que aparece no navegador em caso de exceção não tratada.</li>
						</ul>
						<pre><code class="language-bash">
(venv) $ export FLASK_APP=hello.py
(venv) $ export FLASK_DEBUG=1
(venv) $ flask run
						</code></pre>
						<p><small><b>NUNCA</b> habilite o modo depuração em um servidor de produção!.</small></p>
					</section>
				</section>

				<section>
					<section>
						<h2>Capítulo 3: Templates</h2>
					</section>

					<section>
						<h3>Separação de Lógica</h3>
						<ul>
							<li><b>Lógica de Negócio:</b> Altera o estado da aplicação (ex: adicionar usuário ao BD).</li>
							<li><b>Lógica de Apresentação:</b> Gera a resposta (HTML).</li>
							<li>Misturar as duas torna o código difícil de manter.</li>
							<li><b>Templates:</b> Arquivos de texto com variáveis placeholder para partes dinâmicas.</li>
							<li><b>Renderização:</b> Processo de substituir variáveis por valores reais.</li>
							<li>Flask usa o motor de templates <b>Jinja2</b>.</li>
						</ul>
					</section>

					<section>
						<h3>Sintaxe Jinja2</h3>
						<ul>
							<li>Variáveis: <code>{{ nome_da_variavel }}</code>.</li>
							<li>Estruturas de controle (condicionais, loops): <code>{% if ... %} {% for ... %}</code>.</li>
							<li>Macros: Funções reutilizáveis (<code>{% macro ... %}</code>).</li>
							<li>Inclusão de arquivos: <code>{% include 'arquivo.html' %}</code>.</li>
							<li>Herança de templates:
								<ul>
									<li>Base template (<code>base.html</code>) define blocos: <code>{% block nome_do_bloco %}{% endblock %}</code>.</li>
									<li>Templates derivados estendem o base e preenchem/sobrescrevem blocos: <code>{% extends "base.html" %}</code>.</li>
								</ul>
							</li>
						</ul>
					</section>

					<section>
						<h3>Renderizando Templates no Flask</h3>
						<ul>
							<li>Flask procura templates no subdiretório <code>templates</code>.</li>
							<li>Função <code>render_template()</code> integra Jinja2 com a aplicação.</li>
							<li>Recebe nome do template e argumentos chave-valor para variáveis.</li>
						</ul>
						<pre><code class="language-python">
from flask import Flask, render_template

@app.route('/')
def index():
    return render_template('index.html')

@app.route('/user/<name>')
def user(name):
    return render_template('user.html', name=name)
						</code></pre>
					</section>

					<section>
						<h3>Filtros de Variáveis Jinja2 (Tabela 3-1) </h3>
						<table>
							<thead>
								<tr>
									<th>Filtro</th>
									<th>Descrição</th>
								</tr>
							</thead>
							<tbody>
								<tr>
									<td><code>safe</code></td>
									<td>Renderiza o valor sem aplicar escape HTML. **Cuidado com conteúdo não confiável!** </td>
								</tr>
								<tr>
									<td><code>capitalize</code></td>
									<td>Converte o primeiro caractere para maiúsculo, o resto para minúsculo.</td>
								</tr>
								<tr>
									<td><code>lower</code></td>
									<td>Converte para minúsculas.</td>
								</tr>
								<tr>
									<td><code>upper</code></td>
									<td>Converte para maiúsculas.</td>
								</tr>
								<tr>
									<td><code>title</code></td>
									<td>Capitaliza cada palavra.</td>
								</tr>
								<tr>
									<td><code>trim</code></td>
									<td>Remove espaços em branco iniciais e finais.</td>
								</tr>
								<tr>
									<td><code>striptags</code></td>
									<td>Remove tags HTML.</td>
								</tr>
							</tbody>
						</table>
					</section>

					<section>
						<h3>Integração com Bootstrap (Flask-Bootstrap)</h3>
						<ul>
							<li>Bootstrap: Framework CSS/JS para UI responsiva e atraente.</li>
							<li>Flask-Bootstrap: Extensão Flask para facilitar a integração.</li>
						</ul>
						<pre><code class="language-bash">
# Instalação
(venv) $ pip install flask-bootstrap
						</code></pre>
						<pre><code class="language-python">
# Inicialização
from flask_bootstrap import Bootstrap
bootstrap = Bootstrap(app)
						</code></pre>
						<p><small>Fornece um template base (<code>bootstrap/base.html</code>) para herdar.</small></p>
					</section>

					<section>
						<h3>Templates de Erro Personalizados</h3>
						<ul>
							<li>Flask permite definir páginas de erro personalizadas.</li>
							<li>Decorador <code>app.errorhandler()</code>.</li>
							<li>Retornam o template e o código de status.</li>
						</ul>
						<pre><code class="language-python">
@app.errorhandler(404)
def page_not_found(e):
    return render_template('404.html'), 404

@app.errorhandler(500)
def internal_server_error(e):
    return render_template('500.html'), 500
						</code></pre>
					</section>

					<section>
						<h3>Links e Arquivos Estáticos</h3>
						<ul>
							<li><code>url_for()</code>: Função auxiliar para gerar URLs.
								<ul>
									<li>Evita dependência explícita nas rotas e facilita refatoração.</li>
									<li>Usa o nome da função de view como argumento.</li>
									<li><code>_external=True</code> para URLs absolutas (útil em e-mails).</li>
									<li>Argumentos adicionais viram query strings.</li>
								</ul>
							</li>
							<li>Arquivos Estáticos (CSS, JS, Imagens):
								<ul>
									<li>Flask suporta automaticamente <code>/static/<filename></code>.</li>
									<li>Procura arquivos no subdiretório <code>static</code> da pasta raiz da aplicação.</li>
								</ul>
							</li>
						</ul>
					</section>

					<section>
						<h3>Localização de Datas e Horas (Flask-Moment)</h3>
						<ul>
							<li>Datas/horas são complicadas devido a fusos e locais.</li>
							<li>Solução: Enviar horários UTC para o navegador e usar JavaScript para formatar.</li>
							<li><b>Moment.js:</b> Biblioteca JavaScript para renderizar datas/horas.</li>
							<li><b>Flask-Moment:</b> Extensão para integrar Moment.js com Jinja2.</li>
						</ul>
						<pre><code class="language-bash">
# Instalação
(venv) $ pip install flask-moment
						</code></pre>
						<pre><code class="language-python">
# Inicialização
from flask_moment import Moment
moment = Moment(app)
						</code></pre>
					</section>

					<section>
						<h3>Usando Flask-Moment em Templates</h3>
						<ul>
							<li>Inclua a biblioteca: <code>{{ moment.include_moment() }}</code>.</li>
							<li>Objeto <code>moment</code> disponível no template.</li>
						</ul>
						<pre><code class="language-html">
&lt;p&gt;The local date and time is {{ moment(current_time).format('LLL') }}.&lt;/p&gt;
&lt;p&gt;That was {{ moment(current_time).fromNow(refresh=True) }}&lt;/p&gt;
						</code></pre>
						<p><small><code>format('LLL')</code>: Formato localizado. <code>fromNow()</code>: Timestamp relativo que se atualiza.</small></p>
					</section>
				</section>

				<section>
					<section>
						<h2>Capítulo 4: Processando Dados de Formulário HTML Tradicional no Flask</h2>
					</section>
<section>
<h3>Criando o Formulário HTML</h3>
Você pode criar um formulário HTML puro, estilizado com Bootstrap (ou outro framework CSS), normalmente em seu template Jinja2:
<pre><code class="language-html">
<form method="POST" action="{{ url_for('index') }}">
  <div class="mb-3">
    <label for="name" class="form-label">Qual seu nome?</label>
    <input type="text" class="form-control" id="name" name="name" required>
  </div>
  <button type="submit" class="btn btn-primary">Enviar</button>
</form>
</code></pre>
<ul>
	<li>O atributo <code>method="POST"</code> indica que os dados serão enviados via POST.</li>
	<li>O atributo <code>name="name"</code> no input é importante: é assim que o Flask irá identificar o campo.</li>
</ul>
</section>
<section>
<h3>Rota Flask para Processar o Formulário</h3>
<pre><code class="language-python">
from flask import Flask, render_template, request

app = Flask(__name__)

@app.route('/', methods=['GET', 'POST'])
def index():
    name = None
    if request.method == 'POST':
        # Recupera o valor enviado pelo formulário
        name = request.form.get('name')
    return render_template('index.html', name=name)
</code></pre>
<ul>
	<li><code>request.form</code> é um dicionário especial do Flask que contém os dados enviados via POST.</li>
	<li>Use <code>request.form.get('nome_do_campo')</code> para acessar o valor de um campo do formulário.</li>
</ul>
</section>
<section>
	<h3>Exibindo o Resultado no Template</h3>
	<p>No seu template, você pode exibir o valor recebido:</p>
	<pre><code class="language-html">
	{% if name %}
	<div class="alert alert-success mt-4">Olá, {{ name }}!</div>
	{% endif %}
	</code></pre>
</section>
<section>
	<h3>Exemplo Completo</h3>
	<h4>app.py:</h4>
	<pre><code class="language-python">
	from flask import Flask, render_template, request

	app = Flask(__name__)

	@app.route('/', methods=['GET', 'POST'])
	def index():
		name = None
		if request.method == 'POST':
			name = request.form.get('name')
		return render_template('index.html', name=name)
	</code></pre></section>
	
	<section>
	<h3>Exemplo Completo</h3>
	<h4>templates/index.html:</h4>
	<pre><code class="language-html">
	<!doctype html>
	<html lang="pt-br">
	<head>
		<meta charset="utf-8">
		<title>Formulário Simples Flask</title>
		<link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
	</head>
	<body>
		<div class="container mt-5">
		<h1>Formulário Simples</h1>
		<form method="POST" action="{{ url_for('index') }}">
			<div class="mb-3">
			<label for="name" class="form-label">Qual seu nome?</label>
			<input type="text" class="form-control" id="name" name="name" required>
			</div>
			<button type="submit" class="btn btn-primary">Enviar</button>
		</form>
		{% if name %}
			<div class="alert alert-success mt-4">Olá, {{ name }}!</div>
		{% endif %}
		</div>
	</body>
	</html> 
	</code></pre>
</section>
<section>
	<h3>Resumo</h3>
	<ul>
		<li>Crie um formulário HTML normal no template.</li>
		<li>Use request.form para acessar os dados enviados via POST.</li>
		<li>Exiba o resultado no template conforme necessário.</li>
	</ul>
</section>
</section>
<section>
	<section>
	<h2>Capítulo 5: Estrutura de uma aplicação real</h2>
	</section>
	 <section>
        <h2>Por que reorganizar?</h2>
        <ul>
          <li>Arquivos únicos não escalam bem</li>
          <li>Dificuldade de manutenção com o crescimento</li>
          <li>Separar responsabilidades e facilitar testes</li>
        </ul>
      </section>

      <section>
        <h2>Estrutura sugerida</h2>
        <pre><code>minha_aplicacao/
├── app/
│   ├── main/
│   │   ├── __init__.py
│   │   ├── views.py
│   │   ├── errors.py
│   │   └── forms.py
│   ├── templates/
│   ├── static/
│   ├── models.py
│   ├── email.py
│   └── __init__.py
├── tests/
├── migrations/
├── app.py
├── config.py
└── requirements.txt</code></pre>
      </section>

      <section>
        <h2>Configuração Modular</h2>
        <ul>
          <li>Arquivo <code>config.py</code> com múltiplas classes:</li>
          <ul>
            <li>DevelopmentConfig</li>
            <li>TestingConfig</li>
            <li>ProductionConfig</li>
          </ul>
          <li>Uso de variáveis de ambiente</li>
          <li>Método <code>init_app()</code> para configurações extras</li>
        </ul>
      </section>

      <section>
        <h2>Fábrica de Aplicações</h2>
        <ul>
          <li>Função <code>create_app(config_name)</code></li>
          <li>Permite múltiplas instâncias da aplicação</li>
          <li>Ideal para testes e configuração dinâmica</li>
          <li>Extensões inicializadas com <code>init_app()</code></li>
        </ul>
      </section>

      <section>
        <h2>Blueprints</h2>
        <ul>
          <li>Permitem dividir funcionalidades em módulos</li>
          <li>Rotas e handlers ficam desacoplados da instância principal</li>
          <li>Registrados via <code>app.register_blueprint()</code></li>
          <li>Permite reuso e organização limpa</li>
        </ul>
      </section>

      <section>
        <h2>Exemplo de Blueprint</h2>
        <pre><code># app/main/__init__.py
main = Blueprint('main', __name__)
from . import views, errors

# app/__init__.py
app.register_blueprint(main_blueprint)</code></pre>
      </section>

      <section>
        <h2>Script Principal</h2>
        <ul>
          <li><code>app.py</code> cria a aplicação</li>
          <li>Usa <code>os.getenv('FLASK_CONFIG')</code> para selecionar a config</li>
        </ul>
        <pre><code>app = create_app(...)</code></pre>
      </section>

      <section>
        <h2>Arquivo requirements.txt</h2>
        <ul>
          <li>Gerado com <code>pip freeze &gt; requirements.txt</code></li>
          <li>Reproduz ambientes em outras máquinas</li>
          <li>Deve ser atualizado a cada nova dependência</li>
        </ul>
      </section>

      <section>
        <h2>Execução da Aplicação</h2>
        <ul>
          <li>Definir <code>FLASK_APP=flasky.py</code></li>
          <li>Ativar modo debug com <code>FLASK_DEBUG=1</code></li>
          <li>Executar com <code>flask run</code></li>
        </ul>
      </section>

      <section>
        <h2>Resumo</h2>
        <ul>
          <li>Organização modular facilita manutenção</li>
          <li>Uso de blueprints torna o projeto escalável</li>
          <li>Factory + config por ambiente = flexibilidade</li>
          <li>Base para projetos Flask profissionais</li>
        </ul>
      </section>
</section>
<section>
	<section>
		<h2>Capitulo 6: Persistência de Dados com Arquivos CSV</h2>
	</section>
	<section>
		<h3>Por que usar arquivos?</h3>
		<ul>
			<li>Persistem dados entre execuções da aplicação</li>
			<li>Simples para pequenos projetos ou protótipos</li>
			<li>Evita dependência de banco de dados</li>
		</ul>
	</section>
	<section>
		<h3>Modelo de Produto</h3>
		<ul>
			<li><b>nome</b>: Nome do produto</li>
			<li><b>descrição</b>: Descrição breve</li>
			<li><b>foto</b>: URL da imagem</li>
			<li><b>preço</b>: Valor em reais</li>
		</ul>
	</section>
	<section>
		<h3>Formato do Arquivo CSV</h3>
		<ul>
			<li>Usando <b>CSV</b> para armazenar uma lista de produtos</li>
		</ul>
		<pre><code class="language-csv">
nome,descricao,foto,preco
Camiseta Flask,Camiseta oficial do Flask,https://exemplo.com/camiseta.jpg,59.90
Caneca Python,Caneca personalizada Python,https://exemplo.com/caneca.jpg,34.50
		</code></pre>
	</section>
	<section>
		<h3>Lendo o Catálogo de Produtos</h3>
		<pre><code class="language-python">
import csv

def carregar_produtos():
	produtos = []
	with open('produtos.csv', newline='', encoding='utf-8') as f:
		linhas = f.readlines()
		for linha in linhas[1:]:  # pula o cabeçalho
			nome, descricao, foto, preco = linha.strip().split(',')
			produtos.append({
				'nome': nome,
				'descricao': descricao,
				'foto': foto,
				'preco': float(preco)
			})
	return produtos

@app.route('/catalogo')
def catalogo():
	produtos = carregar_produtos()
	return render_template('catalogo.html', produtos=produtos)
		</code></pre>
	</section>
	<section>
		<h3>Adicionando um Produto</h3>
		<pre><code class="language-python">
def salvar_produto(novo):
	with open('produtos.csv', 'a', newline='', encoding='utf-8') as f:
		linha = f"{novo['nome']},{novo['descricao']},{novo['foto']},{novo['preco']}\n"
		f.write(linha)

@app.route('/adicionar', methods=['POST'])
def adicionar():
	novo = {
		"nome": request.form['nome'],
		"descricao": request.form['descricao'],
		"foto": request.form['foto'],
		"preco": float(request.form['preco'])
	}
	salvar_produto(novo)
	return redirect(url_for('catalogo'))
		</code></pre>
	</section>
	<section>
		<h3>Exibindo o Catálogo no Template</h3>
		<pre><code class="language-html">
<ul>
  {% for produto in produtos %}
	<li>
	  <img src="{{ produto.foto }}" alt="{{ produto.nome }}" style="height:80px;">
	  <strong>{{ produto.nome }}</strong> - R$ {{ produto.preco }}<br>
	  <small>{{ produto.descricao }}</small>
	</li>
  {% endfor %}
</ul>
		</code></pre>
	</section>
	<section>
		<h3>Lendo e Escrevendo CSV com Pandas</h3>
		<ul>
			<li><b>Pandas</b> é uma biblioteca poderosa para manipulação de dados em Python.</li>
			<li>Permite ler, filtrar, modificar e salvar arquivos CSV facilmente.</li>
		</ul>
		<pre><code class="language-python">
	import pandas as pd

	# Lendo o arquivo CSV
	df = pd.read_csv('produtos.csv')

	# Exibindo todos os produtos
	print(df)

	# Adicionando um novo produto
	novo_produto = {
		'nome': 'Adesivo Flask',
		'descricao': 'Adesivo para notebook',
		'foto': 'https://exemplo.com/adesivo.jpg',
		'preco': 9.90
	}
	df = pd.concat([df, pd.DataFrame([novo_produto])], ignore_index=True)

	# Salvando de volta no CSV
	df.to_csv('produtos.csv', index=False)
		</code></pre>
		<ul>
			<li>Com Pandas, você pode realizar buscas, ordenações e análises com poucas linhas de código.</li>
		</ul>
	</section>
	<section>
		<h3>Resumo</h3>
		<ul>
			<li>Use arquivos CSV para persistir dados simples</li>
			<li>Leitura e escrita com <code>f.readlines</code> e <code>f.write</code></li>
			<li>Leitura e escrita usando o <code>pandas</code></li>
		</ul>
	</section>
</section>
<section>
	<h2>Próximos Passos</h2>
	<ul>
		<li>Bancos de Dados com Flask-SQLAlchemy</li>
		<li>Envio de E-mails com Flask-Mail</li>
		<li>Autenticação de usuários</li>
	</ul>
	<h3>Obrigado!</h3>
</section>

			</div>
		</div>

		<script src="https://cdnjs.cloudflare.com/ajax/libs/reveal.js/4.3.1/reveal.min.js"></script>
		<script src="https://cdnjs.cloudflare.com/ajax/libs/reveal.js/4.3.1/plugin/highlight/highlight.min.js"></script>
		<script src="https://cdnjs.cloudflare.com/ajax/libs/reveal.js/4.3.1/plugin/markdown/markdown.min.js"></script>
		<script src="https://cdnjs.cloudflare.com/ajax/libs/reveal.js/4.3.1/plugin/notes/notes.min.js"></script>

		<script>
			// More info about initialization & config:
			// - https://revealjs.com/initialization/
			// - https://revealjs.com/config/
			Reveal.initialize({
				hash: true,

				// Learn about plugins: https://revealjs.com/plugins/
				plugins: [ RevealHighlight, RevealMarkdown, RevealNotes ]
			});
		</script>
	</body></html>